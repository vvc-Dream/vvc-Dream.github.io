<!doctype html>
<html lang="zh-CN">
<head>
	<meta name="baidu-site-verification" content="1COMmuDayL" />
	<meta name="msvalidate.01" content="E41E35607EFA4063D8C1CA15B84D8B8C" />
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.53" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Java面试 | vvc-Dream的博客</title>
    <meta property="og:title" content="Java面试 - vvc-Dream的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-06-27T19:34:58&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-06-27T19:34:58&#43;08:00">
        
    <meta name="Keywords" content="vvc-Dream keywords">
    <meta name="description" content="Java面试">
        <meta name="author" content="vvc-Dream">
        
    <meta property="og:url" content="https://vvc-Dream.github.io/posts/java%E9%9D%A2%E8%AF%95/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
	<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script>
	<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
	<script src="//cdn.bootcss.com/jquery.pjax/1.9.6/jquery.pjax.min.js"></script>
		
		<div class="aplayer" data-id="2625893735" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="1.0">
		</div>
    
<script>
$(document).pjax('a[target!=_blank]', '#main', {fragment:'#main', timeout:8000});
$(document).on('pjax:send', function() { 
    $(".pjax_loading").css("display", "block");
});
$(document).on('pjax:complete', function() { 
    $(".pjax_loading").css("display", "none");
    pajx_loadDuodsuo();
});
function pajx_loadDuodsuo(){
var dus=$(".ds-thread");
if($(dus).length==1){
var el = document.createElement('div');
el.setAttribute('data-thread-key',$(dus).attr("data-thread-key"));
el.setAttribute('data-url',$(dus).attr("data-url"));
DUOSHUO.EmbedThread(el);
$(dus).html(el);
}
}
</script>
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://vvc-Dream.github.io/">
                        vvc-Dream的博客
                    </a>
                
                <p class="description">vvc-Dream subtitle</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://vvc-Dream.github.io/">首页</a>
                    
                    <a  href="https://vvc-Dream.github.io/books/" title="新书">新书</a>
                    
                    <a  href="https://vvc-Dream.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://vvc-Dream.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">Java面试</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年6月27日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://vvc-Dream.github.io/categories/%E5%BC%80%E5%8F%91">开发</a></span>
                            
                        </div>
                        
                        
                        <div class="post-content">
                            <p>Java面试相关，持续更新&hellip;</p>

<hr />

<h4 id="1-一个5l的杯子-一个6l的杯子-得到3l的水">1.一个5L的杯子，一个6L的杯子，得到3L的水</h4>

<p>​   （6-5）得6L杯子里剩余1L水。1L水倒入5L杯子，6L杯子倒满水然后倒入5L杯子里，得6L杯子剩余水2L。一次类推，下一次6L杯子就会剩余水3L。</p>

<hr />

<h4 id="2-烧断一根不均匀的绳子要一个小时-如何得到一小时十五分钟的绳子">2.烧断一根不均匀的绳子要一个小时，如何得到一小时十五分钟的绳子</h4>

<ul>
<li>A绳子两头一起烧，烧完需30min</li>
<li>同时烧上另一根B，上一根烧完则B剩余30min的绳子</li>
<li>然后B点燃两头（烧完15min），同时点燃另一根C，则B烧完C剩余45min绳子。</li>
<li>然后再拿两根绳子，一个烧一头一个烧两天。可得30min绳子。</li>
</ul>

<hr />

<h4 id="3-有一组数-很多-有正有负-如何得出其中相加为0的">3.有一组数，很多，有正有负，如何得出其中相加为0的。</h4>

<ul>
<li>方案一</li>
</ul>

<p>该组数从小到大排列，A只想最小值（最左边），B值向最大值（最右边），</p>

<p>若A+B<0，则A向右移一个单位；若A+B>0，则B向左移一个单位；直至A+B=0;</p>

<ul>
<li>方案二</li>
</ul>

<p>先用set存放该组数，剔除重复值，然后取绝对值并排序（上述也有排序过程），重复值则为和为0的数。</p>

<h4 id="4-什么是tcp-ip协议">4.什么是TCP/IP协议？</h4>

<p>​       可以看作是网络的一中传输规则，就如同在现实生活中开车要遵守交通规则，在网络上传输数据也有它自己的一套规则。TCP/IP协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP等，这些被称为子协议。</p>

<hr />

<h4 id="5-spring理解">5.Spring理解</h4>

<ul>
<li><p>Bean管理</p></li>

<li><p>依赖注入（DI），又称为控制反转（IOC）</p></li>

<li><p>面向切面编程（AOP）</p></li>
</ul>

<h5 id="1-bean管理">(1).Bean管理</h5>

<p>与传统的应用程序不同，在Spring中将对象的创建交给Spring容器来管理，也就是说只有放入Spring容器中的类，Spring才能对其产生作用。那么Spring究竟是怎样获取类的对象的呢？
 要想知道这个，我们首先要弄清楚这几点：
 BeanFactory是Spring容器的根接口，ApplicationContext是它的子接口，通常用它的子接口ApplicationContext来访问Spring容器。</p>

<h6 id="applicationcontext子接口常用的有四个实现类">ApplicationContext子接口常用的有四个实现类：</h6>

<ul>
<li>ClassPathXmlApplicationContext 从 classpath 加载 spring 的配置文件</li>
<li>FileSystemApplicationContext 从系统文件加载 spring 的配置文件</li>
<li>AnnotationConfigApplicationContext 获取基于注解的 spring 容器对象</li>
<li>XmlWebApplicationContext 在 web 环境中获取 spring 容器对象</li>
</ul>

<p>Spring通过BeanFactory来获取这些类的对象，在配置文件中通过<bean/>节点将类交给Spring进行管理，ApplicationContext的实现类通过getBean()方法从Spring容器中获取对象，默认为单例的。</p>

<h5 id="2-依赖注入">(2).依赖注入</h5>

<p>它可以降低类之间的耦合性，有两种注入方式：</p>

<ul>
<li>set注入，在配置文件中使用<property>节点

<br /></li>
</ul>

<p><img src="https:////upload-images.jianshu.io/upload_images/3579909-46ce375ba0a05ec8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667/format/webp" alt="img" /></p>

<p>set注入</p>

<ul>
<li>构造方法注入，在配置文件中使用<constructor-arg>节点

<br /></li>
</ul>

<p><img src="https:////upload-images.jianshu.io/upload_images/3579909-53af0b3342b1cac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/648/format/webp" alt="img" /></p>

<p>构造方法注入</p>

<p>下面举个例子来说明一下什么是依赖注入：
 假设类A因功能F需要调用类B，传统的程序中，我们就会去new一个类B的对象，因而类A就会依赖类于类B，这就是说如果类B不存在，则类A也就无法使用。而使用依赖注入以后，类A只需要去调用实现功能F接口的一个实现类，这个实现类可能是类B,C等等，具体调用谁是有Spring的配置文件决定的，这样类A就不再依赖于类B。
 我们可以这样理解控制反转：
 资源不是由使用资源的双方进行管理，而是由不使用资源的第三方（即Spring容器）进行管理，这样做的好处是：</p>

<ul>
<li>资源集中管理，实现资源的可配置与易管理</li>
<li>降低使用资源双方的依赖程度</li>
</ul>

<p>在传统程序中，当某个角色需要另外一个角色协助时，由调用者来创建被调用者的实例。而在Spring中，创建被调用者的的工作不再由调用者来完成，而由第三方Spring容器来完成，所以称为控制反转，Spring容器创建被调用者的实例，然后注入调用者，所以又称为依赖注入。</p>

<h5 id="3-面向切面编程">(3).面向切面编程</h5>

<p>AOP在Spring中主要表现在两个方面：</p>

<ul>
<li>提供声明式事务管理</li>
<li>Spring支持用户自定义切面</li>
</ul>

<p>面向切面编程是对面向对象编程（OOP）的补充。面向对象编程将程序分解成为各个层次的对象，面向切面编程将程序运行过程分解成各个切面。面向切面编程基于动态代理实现，降低了类直接的耦合程度。Spring的事务管理就是基于AOP实现的。</p>

<hr />

<h4 id="6-strtus2理解">6.strtus2理解</h4>

<p>Struts2是一个按照MVC设计模式设计的web层框架，struts2以webwork为核心，采用拦截器的机制处理用户的请求，这样的设计使得业务逻辑控制器能够与servletAPI完全脱离开。我们可以把struts2理解为一个大大的servlet，而这个servlet就是ActionServlet。</p>

<ul>
<li>Struts2的执行流程？</li>
</ul>

<p>a、浏览器发送请求</p>

<p>b、浏览器请求被Struts2提供的过滤器StrutsPrepareAndExecuteFilter拦截</p>

<p>c、核心控制器FilterDispatcher根据请求决定调用合适的Action</p>

<p>d、Struts2的拦截器链自动对请求应用通用功能，也包含用户自定义的一些拦截器</p>

<p>e、回调Action的execute方法或自定义的action方法，首先这些方法会获得用户请求的参数，然后执行某种数据库的操作</p>

<p>f、返回result视图，处理的结果会被输出到浏览器中</p>

<ul>
<li>拦截器和过滤器有哪些区别？</li>
</ul>

<p>拦截器是基于Java反射机制的，而过滤器是基于函数回调；</p>

<p>拦截器不依赖于servlet容器，而过滤器依赖于servlet容器；</p>

<p>拦截器只对action起作用，而过滤器对几乎所有请求起作用；</p>

<p>拦截器可以访问action上下文，值栈的对象，而过滤器不能；</p>

<p>在action的生命周期中，拦截器可以被多从调用，而过滤器只能在初始化的时候被调用一次；</p>

<ul>
<li>简单介绍一下struts2的值栈？</li>
</ul>

<p>值栈是对应每一个请求对象的数据存储中心。struts2的一个很重要的特点就是引入了值栈。之前我们通过缓存或者模型驱动在action和页面之间传递数据，数据混乱，并且难以管理，缓存还有时间限制，使用起来非常困难。值栈的引入解决了这个问题，它可以统一管理页面和action之间的数据，供action、result、interceptor等使用。我们大多数情况下都不需要考虑值栈在哪里，只需要获取相应的数据就可以啦，这大大降低了开发人员的工作量。</p>

<hr />

<h4 id="7-servlet与jsp区别">7.servlet与JSP区别</h4>

<p>​   JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码,Web容器将JSP的代码编译成JVM能够识别的java类。</p>

<ul>
<li>JSP 工作原理：</li>
</ul>

<p>JSP页面在执行的时候都会被服务器端的JSP引擎转换为Servelet（.java），然后又由JSP引擎调用Java编译器，将Servelet（.java）编译为Class文件（.class），并由Java虚拟机（JVM）解释执行。</p>

<pre><code>Servlet的应用逻辑是在Java文件中，从Java代码中动态输出HTML，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。
</code></pre>

<hr />

<h4 id="8-springmvc理解">8.SpringMVC理解</h4>

<ul>
<li><p>Spring MVC 中的MVC （modal、view、controller）分别是 模型、视图、控制器</p></li>

<li><p>Spring的模型-视图-控制器（MVC），该框架是围绕一个DispatcherServlet来设计的，这个DispatcherServlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、等，甚至还能支持文件上传等功能。</p></li>

<li><p>运行原理</p></li>
</ul>

<p>1、 首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p>

<p>2、 DispatcherServlet——&gt;HandlerMapping，由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller,HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</p>

<p>3、 DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p>

<p>4、 HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回给DispatcherServlet一个ModelAndView对象（包含模型数据、逻辑视图名）；</p>

<p>5、 ModelAndView的逻辑视图名——&gt; ViewResolver， DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图,ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</p>

<p>6、 View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</p>

<h2 id="7-返回控制权给dispatcherservlet-由dispatcherservlet返回响应给用户-到此一个流程结束">7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</h2>

<h4 id="9-整形变量是否存在栈中">9.整形变量是否存在栈中</h4>

<p>​   不管成员变量还是局部变量，如果是基础数据类型，那么值存于栈中。如果是应用数据类型，其引用放在栈里，对象实体放在堆里。</p>

<hr />

<h4 id="10-xml-和-json">10.XML 和 JSON</h4>

<ul>
<li>XML</li>
</ul>

<blockquote>
<p>可扩展标记语言（英语：Extensible Markup Language，简称：XML）.用来传输及存储数据信息，不用来表现或展示数据。</p>
</blockquote>

<ul>
<li>JSON</li>
</ul>

<blockquote>
<ul>
<li>JSON 是一个轻量级的数据格式 ，不是一种编程语言。JSON是一个JavaScript 的严格的子集，利用JavaScript 中一些模式来表示结构化数据。</li>
<li>与XML 相比，JSON是在JS中读写结构化数据更好的 方式，因为它可以把JSON 直接传给eval(),而不必创建 DOM 对象。</li>
</ul>
</blockquote>

<ul>
<li>平台无关性,语言无关性,系统无关性</li>

<li><p>XML可读性比JSON强，XML更符合人类语言习惯</p></li>

<li><p>XML解析</p></li>
</ul>

<p>基本的解析方式有两种,一种叫<strong>SAX</strong>，另一种叫<strong>DOM</strong>。</p>

<hr />

<h4 id="11-集合底层实现原理">11.集合底层实现原理</h4>

<ul>
<li>ArrayList实现原理要点概括</li>
</ul>

<ol>
<li>ArrayList是List接口的可变数组非同步实现，并允许包括null在内的所有元素。</li>
<li>底层使用数组实现</li>
<li>该集合是可变长度数组，数组扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量增长大约是其容量的1.5倍，这种操作的代价很高。</li>
<li>采用了Fail-Fast机制，面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li>
<li>remove方法会让下标到数组末尾的元素向前移动一个单位，并把最后一位的值置空，方便GC</li>
</ol>

<ul>
<li>LinkedList实现原理要点概括</li>
</ul>

<ol>
<li>LinkedList是List接口的双向链表非同步实现，并允许包括null在内的所有元素。</li>
<li>底层的数据结构是基于双向链表的，该数据结构我们称为节点</li>
<li>双向链表节点对应的类Node的实例，Node中包含成员变量：prev，next，item。其中，prev是该节点的上一个节点，next是该节点的下一个节点，item是该节点所包含的值。</li>
<li>它的查找是分两半查找，先判断index是在链表的哪一半，然后再去对应区域查找，这样最多只要遍历链表的一半节点即可找到</li>
</ol>

<ul>
<li>HashMap实现原理要点概括</li>
</ul>

<ol>
<li>HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。</li>
<li>底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。</li>
<li>HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。</li>
<li>HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能</li>
<li>采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常</li>
</ol>

<ul>
<li>Hashtable实现原理要点概括</li>
</ul>

<ol>
<li>Hashtable是基于哈希表的Map接口的同步实现，不允许使用null值和null键</li>
<li>底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体</li>
<li>Hashtable在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</li>
<li>synchronized是针对整张Hash表的，即每次锁住整张表让线程独占</li>
</ol>

<ul>
<li>ConcurrentHashMap实现原理要点概括</li>
</ul>

<ol>
<li>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。</li>
<li>它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。</li>
<li>ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</li>
<li>与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)</li>
<li>ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。</li>
</ol>

<ul>
<li>HashSet实现原理要点概括</li>
</ul>

<ol>
<li>HashSet由哈希表(实际上是一个HashMap实例)支持，不保证set的迭代顺序，并允许使用null元素。</li>
<li>基于HashMap实现，API也是对HashMap的行为进行了封装，可参考HashMap</li>
</ol>

<ul>
<li>LinkedHashMap实现原理要点概括</li>
</ul>

<ol>
<li>LinkedHashMap继承于HashMap，底层使用哈希表和双向链表来保存所有元素，并且它是非同步，允许使用null值和null键。</li>
<li>基本操作与父类HashMap相似，通过重写HashMap相关方法，重新定义了数组中保存的元素Entry，来实现自己的链接列表特性。该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而构成了双向链接列表。</li>
</ol>

<ul>
<li>LinkedHashSet实现原理要点概括</li>
</ul>

<ol>
<li>对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同。</li>
</ol>

<hr />

<h4 id="12-jsp内置对象">12.JSP内置对象</h4>

<ul>
<li>内置对象简介</li>
</ul>

<p>JSP 内置对象是 Web 容器创建的一组对象，不需使用 new 关键字就可以直接使用的内置对象。</p>

<ul>
<li>九大内置对象

<ol>
<li>五大常用的内置对象：out、request、reponse、session、application</li>
<li>不常用的内置对象：Page、pageContext、exception、config</li>
</ol></li>
</ul>

<hr />

<h4 id="13-session的生命周期">13.session的生命周期</h4>

<p>Session中的数据保存在服务器端。Session指的就是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。</p>

<ul>
<li>Session的销毁

<ol>
<li>session调用了session.invalidate()方法.</li>
<li>前后两次请求超出了session指定的生命周期时间.</li>
</ol></li>
</ul>

<hr />

<h4 id="14-cookie的生命周期">14.cookie的生命周期</h4>

<p>cookie中的数据保存在客户端端。cookie的生命周期可以通过cookie.setMaxAge(2000);来设置，如果没有设置setMaxAge,则cookie的生命周期当浏览器关闭的时候，就消亡了。</p>

<hr />

<h4 id="15-servlet-strtus2-springmvc是单例还是多例">15.servlet、strtus2、springMVC是单例还是多例</h4>

<ul>
<li><p>struts2中action是多例的，即一个session产生一个action</p></li>

<li><p>而servlet采用单实例多线程模式开发，减少产生servlet实例的开销。</p></li>

<li><p>Springmvc默认是单例模式</p></li>
</ul>

<hr />

<h4 id="16-java新建类的方式">16.Java新建类的方式</h4>

<ol>
<li>使用new关键字</li>
</ol>

<pre><code class="language-java">   Employee emp1 = new Employee();
</code></pre>

<ol>
<li>使用Class类的newInstance方法</li>
</ol>

<pre><code class="language-java">   Employee emp2 = (Employee) Class.forName(&quot;org.programming.mitra.exercises.Employee&quot;).newInstance();
   //或者
   Employee emp2 = Employee.class.newInstance();
</code></pre>

<ol>
<li>使用Constructor类的newInstance方法</li>
</ol>

<pre><code class="language-java">   Constructor&lt;Employee&gt; constructor = Employee.class.getConstructor();
   Employee emp3 = constructor.newInstance();
</code></pre>

<ol>
<li>使用clone方法</li>
</ol>

<pre><code class="language-java">   Employee emp4 = (Employee) emp3.clone();
</code></pre>

<ol>
<li>使用反序列化</li>
</ol>

<pre><code class="language-java">   ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;data.obj&quot;));
   Employee emp5 = (Employee) in.readObject();
</code></pre>

<hr />

<h4 id="17-mysql优化">17.Mysql优化</h4>

<p>MySQL优化三大方向
① 优化MySQL所在服务器内核(此优化一般由运维人员完成)。
② 对MySQL配置参数进行优化（my.cnf）此优化需要进行压力测试来进行参数调整。
③ 对SQL语句以及表优化。
MySQL参数优化
1:MySQL 默认的最大连接数为 100，可以在 mysql 客户端使用以下命令查看
mysql&gt; show variables like &lsquo;max_connections&rsquo;;
2:查看当前访问Mysql的线程
mysql&gt; show processlist;
3:设置最大连接数
mysql&gt;set globle max_connections = 5000;
最大可设置16384,超过没用
4:查看当前被使用的connections
mysql&gt;show globle status like &lsquo;max_user_connections&rsquo;
对MySQL语句性能优化的16条经验
① 为查询缓存优化查询
② EXPLAIN 我们的SELECT查询(可以查看执行的行数)
③ 当只要一行数据时使用LIMIT 1
④ 为搜索字段建立索引
⑤ 在Join表的时候使用相当类型的列，并将其索引
⑥ 千万不要 ORDER BY RAND  ()
⑦ 避免SELECT *
⑧ 永远为每张表设置一个ID
⑨ 可以使用ENUM 而不要VARCHAR
⑩ 尽可能的使用NOT NULL
⑪ 固定长度的表会更快
⑫ 垂直分割
⑬ 拆分打的DELETE或INSERT语句
⑭ 越小的列会越快
⑮ 选择正确的存储引擎
⑯ 小心 &ldquo;永久链接&rdquo;</p>

<p><a href="https://blog.csdn.net/u013087513/article/details/77899412">MySQL优化技巧</a></p>

<hr />

<h4 id="18-mysql-explain">18.Mysql Explain</h4>

<p>expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra,下面对这些字段出现的可能进行解释：</p>

<p>一、 <strong>id</strong></p>

<p>​     <strong>我的理解是SQL执行的顺序的标识,SQL从大到小的执行</strong></p>

<p>\1. id相同时，执行顺序由上至下</p>

<p>\2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>

<p>3.id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p>

<p><strong>二、select_type</strong></p>

<p>​      <strong>示查询中每个select子句的类型</strong></p>

<p>(1) SIMPLE(简单SELECT,不使用UNION或子查询等)</p>

<p>(2) PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)</p>

<p>(3) UNION(UNION中的第二个或后面的SELECT语句)</p>

<p>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p>

<p>(5) UNION RESULT(UNION的结果)</p>

<p>(6) SUBQUERY(子查询中的第一个SELECT)</p>

<p>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)</p>

<p>(8) DERIVED(派生表的SELECT, FROM子句的子查询)</p>

<p>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p>

<p><strong>三、table</strong></p>

<p>显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)</p>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p>

<pre><code>mysql&gt; explain select * from (select * from ( select * from t1 where id=2602) a) b;
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       |
|  2 | DERIVED     | &lt;derived3&gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       |
|  3 | DERIVED     | t1         | const  | PRIMARY,idx_t1_id | PRIMARY | 4       |      |    1 |       |
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
</code></pre>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></p>

<p><strong>四、type</strong></p>

<p>表示MySQL在表中找到所需行的方式，又称“访问类型”。</p>

<p>常用的类型有： <strong>ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</strong></p>

<p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p>

<p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p>

<p>range:只检索给定范围的行，使用一个索引来选择行</p>

<p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>

<p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p>

<p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system</p>

<p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>

<p><strong>五、possible_keys</strong></p>

<p><strong>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</strong></p>

<p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。
如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p>

<p><strong>六、Key</strong></p>

<p><strong>key列显示MySQL实际决定使用的键（索引）</strong></p>

<p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>

<p><strong>七、key_len</strong></p>

<p><strong>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</strong></p>

<p>不损失精确性的情况下，长度越短越好</p>

<p><strong>八、ref</strong></p>

<p><strong>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</strong></p>

<p><strong>九、rows</strong></p>

<p><strong>表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</strong></p>

<p><strong>十、Extra</strong></p>

<p><strong>该列包含MySQL解决查询的详细信息,有以下几种情况：</strong></p>

<p>Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p>

<p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询</p>

<p>Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”</p>

<p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p>

<p>Impossible where：这个值强调了where语句会导致没有符合条件的行。</p>

<p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p>

<p><a href="https://www.cnblogs.com/xuanzhi201111/p/4175635.html">Mysql Explain</a></p>

<hr />

<h4 id="19-分布式唯一id生成的几种方式">19.分布式唯一ID生成的几种方式</h4>

<ol>
<li>UUID</li>
</ol>

<p>唯一性：确保生成的ID是全网唯一的。</p>

<p>有序递增性：确保生成的ID是对于某个用户或者业务是按一定的数字有序递增的。</p>

<p>高可用性：确保任何时候都能正确的生成ID。</p>

<p>带时间：ID里面包含时间，一眼扫过去就知道哪天的交易。</p>

<ol>
<li>数据库自增ID</li>
</ol>

<p>使用数据库的id自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。</p>

<p>优点：数据库生成的ID绝对有序，高可用实现方式简单</p>

<p>缺点：需要独立部署数据库实例，成本高，有性能瓶颈</p>

<ol>
<li>批量生成ID（数据库+Java）</li>
</ol>

<p>一次按需批量生成多个ID，每次生成都需要访问数据库，将数据库修改为最大的ID值，并在内存中记录当前值及最大值。</p>

<p>优点：避免了每次生成ID都要访问数据库并带来压力，提高性能</p>

<p>缺点：属于本地生成策略，存在单点故障，服务重启造成ID不连续</p>

<ol>
<li>Redis生成ID</li>
</ol>

<p>Redis的所有命令操作都是单线程的，本身提供像 incr 和 increby 这样的自增原子命令，所以能保证生成的 ID 肯定是唯一有序的。</p>

<p>优点：不依赖于数据库，灵活方便，且性能优于数据库；数字ID天然排序，对分页或者需要排序的结果很有帮助。</p>

<p>缺点：如果系统中没有Redis，还需要引入新的组件，增加系统复杂度；需要编码和配置的工作量比较大。</p>
                        </div>

                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/java%E9%9B%86%E5%90%88%E5%85%A5%E9%97%A8%E5%92%8C%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/">Java集合入门和深入学习</a></li>
        
        <li><a href="/posts/java%E4%B8%ADclone%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/">Java中clone方法的实现</a></li>
        
        <li><a href="/posts/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96serialization%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">Java对象的序列化（Serialization）和反序列化</a></li>
        
        <li><a href="/posts/%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95%E5%92%8Cequals%E6%96%B9%E6%B3%95/">重写hashCode方法和equals方法</a></li>
        
        <li><a href="/posts/equals%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB/">Equals与==的区别</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://vvc-Dream.github.io/tags/java">java</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://vvc-Dream.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/%E6%89%8B%E6%9C%BApc%E6%8A%95%E5%B1%8F/" title="手机PC投屏">手机PC投屏</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/win10%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/" title="Win10效率工具">Win10效率工具</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/win10%E7%BE%8E%E5%8C%96/" title="Win10美化">Win10美化</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/java%E9%9D%A2%E8%AF%953/" title="Java面试（3）">Java面试（3）</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/java%E9%9D%A2%E8%AF%95%E8%BF%9B%E9%98%B6/" title="Java面试（进阶）">Java面试（进阶）</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/mysql%E7%B4%A2%E5%BC%95/" title="Mysql索引">Mysql索引</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/java%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/" title="Java单点登陆">Java单点登陆</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/seeion%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E5%88%9B%E5%BB%BA%E7%9A%84/" title="Seeion是什么时候被创建的">Seeion是什么时候被创建的</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/object%E7%B1%BB/" title="Object类">Object类</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/java%E9%9D%A2%E8%AF%95/" title="Java面试">Java面试</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://vvc-Dream.github.io/categories/%E5%B7%A5%E5%85%B7/">工具(2)</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/categories/%E5%BC%80%E5%8F%91/">开发(21)</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/categories/%E6%9D%82%E6%8A%80%E6%B5%85%E5%B0%9D/">杂技浅尝(1)</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/categories/%E7%BE%8E%E5%8C%96/">美化(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://vvc-Dream.github.io/tags/hugo/">hugo</a>
    
    <a href="https://vvc-Dream.github.io/tags/insurance/">insurance</a>
    
    <a href="https://vvc-Dream.github.io/tags/java/">java</a>
    
    <a href="https://vvc-Dream.github.io/tags/win/">win</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://github.com/vvc-Dream/vvc-Dream.github.io" title="Github">Github</a>
        </li>
        
        <li>
            <a target="_blank" href="http://space.bilibili.com/44178647?" title="哔哩哔哩">哔哩哔哩</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://vvc-Dream.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2018 <a href="https://vvc-Dream.github.io/">vvc-Dream的博客 By vvc-Dream</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
