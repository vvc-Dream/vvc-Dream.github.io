<!doctype html>
<html lang="zh-CN">
<head>
	<meta name="baidu-site-verification" content="1COMmuDayL" />
	<meta name="msvalidate.01" content="E41E35607EFA4063D8C1CA15B84D8B8C" />
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.53" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>基本数据类型与包装数据类型 | vvc-Dream的博客</title>
    <meta property="og:title" content="基本数据类型与包装数据类型 - vvc-Dream的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-06-03T22:13:57&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-06-03T22:13:57&#43;08:00">
        
    <meta name="Keywords" content="vvc-Dream keywords">
    <meta name="description" content="基本数据类型与包装数据类型">
        <meta name="author" content="vvc-Dream">
        
    <meta property="og:url" content="https://vvc-Dream.github.io/posts/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
	<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script>
	<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
	<script src="//cdn.bootcss.com/jquery.pjax/1.9.6/jquery.pjax.min.js"></script>
		
		<div class="aplayer" data-id="2625893735" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-volume="1.0">
		</div>
    
<script>
$(document).pjax('a[target!=_blank]', '#main', {fragment:'#main', timeout:8000});
$(document).on('pjax:send', function() { 
    $(".pjax_loading").css("display", "block");
});
$(document).on('pjax:complete', function() { 
    $(".pjax_loading").css("display", "none");
    pajx_loadDuodsuo();
});
function pajx_loadDuodsuo(){
var dus=$(".ds-thread");
if($(dus).length==1){
var el = document.createElement('div');
el.setAttribute('data-thread-key',$(dus).attr("data-thread-key"));
el.setAttribute('data-url',$(dus).attr("data-url"));
DUOSHUO.EmbedThread(el);
$(dus).html(el);
}
}
</script>
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://vvc-Dream.github.io/">
                        vvc-Dream的博客
                    </a>
                
                <p class="description">vvc-Dream subtitle</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://vvc-Dream.github.io/">首页</a>
                    
                    <a  href="https://vvc-Dream.github.io/books/" title="新书">新书</a>
                    
                    <a  href="https://vvc-Dream.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://vvc-Dream.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">基本数据类型与包装数据类型</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年6月3日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://vvc-Dream.github.io/categories/%E5%BC%80%E5%8F%91">开发</a></span>
                            
                        </div>
                        
                        
                        <div class="post-content">
                            <p>作为一名程序员，我觉得会多门语言的前提，必须把一门语言熟练掌握，才能触类旁通，因此，也就出现了这次的Java基础与深入之旅啦！欢迎大家关注这一系列。</p>

<p>这一系列打算慢慢地去接触源码，并且列出相关的题目，对于完全的初学者的话，我到时候会搜一套我认为比较好的培训机构的视频以及给些社区资料和相关博客咯。让我们一起开始思考，深入学习Java吧。</p>

<hr />

<h3 id="这篇文章就数据类型咯-文章结构">这篇文章就数据类型咯-文章结构：</h3>

<ol>
<li>基本数据类型的系统描述；</li>
<li>数据类型的包装类理解（含源码解析）；</li>
<li>数据类型转换、装包拆包等一些小坑。</li>
</ol>

<hr />

<h3 id="一-基本数据类型的系统描述">一、基本数据类型的系统描述：</h3>

<h4 id="1-总述-java基本数据类型分为两大类-boolean类型和数值类型-数值类型可分为整数类型和浮点类型-而其中字符类型可单独对待-所以java只包含8种基本数据类型">1. <strong>总述</strong>：Java基本数据类型分为两大类：boolean类型和数值类型。数值类型可分为整数类型和浮点类型，而其中字符类型可单独对待。所以Java只包含8种基本数据类型。</h4>

<p>！注意！字符串不是基本数据类型，字符串是一个类，是一个引用类型。这个在下一篇我们会仔细讨论它！</p>

<p>boolean 数值只有true和false，不能用0代替。其他数值类型不能转换成boolean。包装类–Boolean</p>

<p>byte 内存8位，无符号位时最大存储255，表数范围：-128~127。包装类–Byte</p>

<p>short 内存16位，无符号位时最大存储65536，表数范围：-32768~32767。包装类–Short</p>

<p>int 内存32位，无符号位时最大存储2的32次方减1，表数范围：负的2的31次方到正的2的31次方减1。包装类–Integer。</p>

<p>long 内存64位，无符号位时最大存储2的64次方减1，表数范围：负的2的63次方到正的2的63次方减1。包装类–Long。</p>

<p>float 内存32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。包装类–Float。</p>

<p>double 内存64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。包装类–Double。</p>

<p>char：16位，存储Unicode字符集，用单引号赋值。可以参与加减乘除运算的，也可以比较大小的！！包装类–Character。</p>

<hr />

<h2 id="二-数据类型的包装类理解-含部分源码解析">二、数据类型的包装类理解（含部分源码解析）</h2>

<p>首先要知道为什么Java会为每一个基础数据类型都提供一个相应包装类的目的，在于将Java的所有东西都抽象成对象，可以更方便的控制和使用。这就是面向对象！</p>

<p>然后对于包装类，主要作用是：1.作为和基本数据类型对应的类类型存在，方便涉及到对象的操作。2.包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。</p>

<h3 id="下面我们将一起讨论下包装类中的重要源码">下面我们将一起讨论下包装类中的重要源码！！</h3>

<h4 id="1-深入boolean基本类型-boolean类以及细节点">1.深入boolean基本类型、Boolean类以及细节点：</h4>

<pre><code class="language-java">//看接口是可序列化，是一个final修饰的类
public final class Boolean implements java.io.Serializable,
                                      Comparable&lt;Boolean&gt;{
     //看这两个对应的原始对象。享元模式的使用，达到多个对象都使用一份内存。至于什么是享元，以及它与单例的区别，这里就不多说了。
	 public static final Boolean TRUE = new Boolean(true);
	 public static final Boolean FALSE = new Boolean(false);
	 private final boolean value;
	 //两个构造器，可见它是可以为null的啦，使用Boolean这个类的话
	 public Boolean(boolean value) {
        this.value = value;
    }
     public Boolean(String s) {
        this(parseBoolean(s));
    }
     public static boolean parseBoolean(String s) {
        return ((s != null) &amp;&amp; s.equalsIgnoreCase(&quot;true&quot;));
    }
    //jdk文档建议用valueOf代替new方式来创建Boolean类对象。new创建的Boolean对象是不断的新创建一个实例对象，而valueOf则是返回Boolean类里的静态成员变量,也就是使用享元模式的那个对象。
    public static Boolean valueOf(String s) {
        return parseBoolean(s) ? TRUE : FALSE;
    }

    //下面是令人困惑的设计了，我也是看了下stackoverflow里面讨论才有点懂。
    //原汁原味链接：http://stackoverflow.com/questions/3912303/boolean-hashcode
    //1. 使用质素是因为假如要把Boolean指插入到hashtable中，如果不是质素的话可能会比较容易造成哈希冲突。符合对象计算hashcode的时候通常会把各个属性的hashcode相加然后再做hash,如果是比较小的质素，容易造成hash分布不均匀。
    //2. Maps是可以包裹Boolean的，而如果map除了包含Boolean对象，还包含其他对象，那么如果不适当处理，就很容易有冲突了
	 public static int hashCode(boolean value) {
        return value ? 1231 : 1237;
    }
    //好恐怖和缜密的源码设计。
}
</code></pre>

<h4 id="总括下">总括下：</h4>

<p>1.boolean是基础数据类型，而Boolean是一个类。
2.boolean一般存在于桟空间中，而Boolean对象存在堆空间中。
3.boolean有true和false俩种值，Boolean除了true和false外，还有null。</p>

<h3 id="下面我们看份代码-解析在代码中">下面我们看份代码：（解析在代码中）</h3>

<pre><code class="language-java">public class Main {
    public static void main (String []args)
    {
        Boolean bool1 = Boolean.valueOf(true);       //这里均使用valueof创建对象，new创建的Boolean对象是不断的新创建一个实例对象，而valueOf则是返回Boolean类里的静态成员变量
        Boolean bool2 = Boolean.valueOf(&quot;True&quot;);    //这里上一句代码验证使用String变量作为参数时，不区分大小写的。
        Boolean bool3 = Boolean.valueOf(&quot;ASD&quot;);
        boolean x1 = bool1.booleanValue();
        boolean x2 = bool2.booleanValue();
        System.out.println(&quot;bool1:&quot; + x1 + &quot;,bool2:&quot; + x2 + &quot;,bool3:&quot; + bool3);
        boolean x3 = bool1.equals(bool2);       //这个就是验证享元模式，使用的是同一个对象
        boolean x4 = bool1.equals(bool3);       //肯定不是同一对象啦。
        System.out.println(&quot;bool1.equals(bool2):&quot; + x3 + &quot;,bool1.equals(bool3):&quot; + x4);
        String str1 = Boolean.toString(bool1);      //可见Boolean对象是可以转换成字符的
        String str2 = Boolean.toString(false);      
        String str3 = bool3.toString();
        System.out.println(&quot;bool1:&quot; + str1 + &quot;,str2:&quot; + str2 + &quot;,bool3:&quot; + str3);
        boolean x5 = Boolean.parseBoolean(&quot;ASD&quot;);         //源码是直接判断然后与true对比，因此打印为false
        System.out.println(x5);
    }
}
</code></pre>

<hr />

<h3 id="2-深入byte基本类型">2.深入byte基本类型</h3>

<h4 id="先来份byte源码">先来份Byte源码</h4>

<pre><code class="language-java">//也可以看到是一个final修饰的类，只能用，不能被继承咯
public final class Byte extends Number implements Comparable&lt;Byte&gt;{
	public static final int SIZE = 8;   //只能是一个字节咯
	//两个构造器
	public Byte(byte value) {
        this.value = value;   //传入的要为Byte类型的值
    }
    public Byte(String s) throws NumberFormatException {
        this.value = parseByte(s, 10);  //传入的要求是可转换成Byte的字符串
    }
    //这个Byte做了缓存
    private static class ByteCache {
        private ByteCache(){}

        static final Byte cache[] = new Byte[-(-128) + 127 + 1];//声明缓存数组的长度为256

        static {
            for(int i = 0; i &lt; cache.length; i++)
                cache[i] = new Byte((byte)(i - 128));//然后将-128~127进行缓存
        }
    }
    //两个解析字符串方法
    public static byte parseByte(String s, int radix)
        throws NumberFormatException {
        //radix是解析字符串时候的基数，在此方法下有个解析基数的含义。
        int i = Integer.parseInt(s, radix);//解析字符串并返回，所以s必须是-128~127的字符，至于为什么用这个方法int的包装类方法来解析，一会我们会谈到。
        if (i &lt; MIN_VALUE || i &gt; MAX_VALUE)
            throw new NumberFormatException(
                &quot;Value out of range. Value:\&quot;&quot; + s + &quot;\&quot; Radix:&quot; + radix);
        return (byte)i;
    }
    //也是解码转码方法，将String转为Byte
    public static Byte decode(String nm) throws NumberFormatException {
        int i = Integer.decode(nm);//一会重点讲解Integer的系列方法
        if (i &lt; MIN_VALUE || i &gt; MAX_VALUE)
            throw new NumberFormatException(
                    &quot;Value &quot; + i + &quot; out of range from input &quot; + nm);
        return valueOf((byte)i);
    }
}
</code></pre>

<h4 id="解释radix的作用">解释radix的作用</h4>

<p>b[0] = Byte.parseByte(“11”, 2) = 3
表示 字符串11以2为基数表示为10进制的byte值是 3 ，这里的11表示的是一个2进制数
b[0] = Byte.parseByte(“11”, 3) = 4
表示 字符串11以3为基数表示为10进制的byte值是 4 ，这里的11表示的是一个3进制数</p>

<pre><code class="language-java">//另外这样使用byte是不会报错的：
byte=55;
//因为会自动把56当成byte类型去处理的了。
</code></pre>

<hr />

<h3 id="3-就是重点的int与integer啦">3.就是重点的int与Integer啦</h3>

<p>先吃份源码Integer解析套餐</p>

<pre><code class="language-java">public final class Integer extends Number implements Comparable&lt;Integer&gt; {
	
	 public static final Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;);//原始类型int的Class实例。
	 //所有可能的将数字表示为字符串的字符集合做缓存。
	 final static char[] digits = {
        '0' , '1' , '2' , '3' , '4' , '5' ,
        '6' , '7' , '8' , '9' , 'a' , 'b' ,
        'c' , 'd' , 'e' , 'f' , 'g' , 'h' ,
        'i' , 'j' , 'k' , 'l' , 'm' , 'n' ,
        'o' , 'p' , 'q' , 'r' , 's' , 't' ,
        'u' , 'v' , 'w' , 'x' , 'y' , 'z'
    };
	//两个构造器
	 public Integer(int value) {
        this.value = value;
    }
    public Integer(String s) throws NumberFormatException {
        this.value = parseInt(s, 10);//涉及了String转换成int，一会仔细讨论这个。
    }
    //像上面Byte类型中解释的那样的方法，返回第二个参数所指定的进制数的第一个参数的字符串表示形式。处理各种进制的Integer.
    public static String toString(int i, int radix) {
        if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)             
        radix = 10;//默认为10进制 
        /* Use the faster version */         
        if (radix == 10) {             
            return toString(i);         
        }
        char buf[] = new char[33];         
        boolean negative = (i &lt; 0);         
        int charPos = 32;
        //统一转为负数去处理
        if (!negative) {             
            i = -i;         
        }
        while (i &lt;= -radix) {             
            buf[charPos--] = digits[-(i % radix)];             
            i = i / radix;         
        }         
        buf[charPos] = digits[-i];
        if (negative) {             
            buf[--charPos] = '-';         
        }
        return new String(buf, charPos, (33 - charPos));     
    }
    //一会有事例代码演示这个，这个其实就是把int型包装成Integer然后再转化成String字符串
     public static String toString(int i) {
        if (i == Integer.MIN_VALUE)
            return &quot;-2147483648&quot;;
        int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);
        char[] buf = new char[size];
        getChars(i, size, buf);
        return new String(buf, true);
    }
    //与toString组合形成一方法去转换成字符串咯
    static void getChars(int i, int index, char[] buf) {
        int q, r;
        int charPos = index;
        char sign = 0;

        if (i &lt; 0) { //如果i为负数，则设置i的符号字符为'-'。
            sign = '-';  //确定正负数
            i = -i;  //将负数转化为正数处理，提高效率 
        }

        // Generate two digits per iteration
        while (i &gt;= 65536) { //如果i大于65536，则每一次都获取十位和个位上的数字对应的字符。将值判断大小后取每个数字，较大的数字一次取两位（大数字运算消耗大）
            q = i / 100;
        // really: r = i - (q * 100);
            r = i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)); //利用位运算，每次获得i的最后两位数，不断循环提取处理
            i = q;//重新赋值，准备下一次循环 
            buf [--charPos] = DigitOnes[r]; //存储r中在个位数集合中对应的字符
            buf [--charPos] = DigitTens[r]; //存储r中在十位数集合中对应的字符
        }

        // Fall thru to fast mode for smaller numbers
        // assert(i &lt;= 65536, i);
        for (;;) { //i&lt;65536的情况，小数字运算消耗较小，故一次只取一位
            q = (i * 52429) &gt;&gt;&gt; (16+3);//52429/(2*19)约等于1，此处这样设计是为了提高精度
            r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1));  // r = i-(q*10) ... //每次获得i的最后两位数
            buf [--charPos] = digits [r];//取最后一位的数字  
            i = q;//重新赋值，准备下一次循环  
            if (i == 0) break;
        }
        if (sign != 0) {
            buf [--charPos] = sign; //设置符号
        }
    }
    //下面两个是用来确定字符串长度的。
    //定义sizeTable表示int中每个位数中最大的数，用于简便确定int数的长度。
    final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,
                                      99999999, 999999999, Integer.MAX_VALUE };
    //使用上面的sizeTable定义来确定int数的字符串表示长度。           
    static int stringSize(int x) {
        for (int i=0; ; i++)
            if (x &lt;= sizeTable[i])
                return i+1;
    }
    //炒鸡重要的方法啦！！parseInt(String s,int radix)使用第二个参数指定的基数，将字符串参数解析为有符号的整数。 parseInt(String s)只能将数字字符串转化十进制数
     public static int parseInt(String s, int radix)
                throws NumberFormatException
    {
        /*
         * WARNING: This method may be invoked early during VM initialization
         * before IntegerCache is initialized. Care must be taken to not use
         * the valueOf method.
         */

        if (s == null) {//参数检验，调用方法前检查参数的正确性。
            throw new NumberFormatException(&quot;null&quot;);
        }

        if (radix &lt; Character.MIN_RADIX) {
            throw new NumberFormatException(&quot;radix &quot; + radix +
                                            &quot; less than Character.MIN_RADIX&quot;);
        }

        if (radix &gt; Character.MAX_RADIX) {
            throw new NumberFormatException(&quot;radix &quot; + radix +
                                            &quot; greater than Character.MAX_RADIX&quot;);
        }

        int result = 0;
        boolean negative = false;
        int i = 0, len = s.length();//i表示当前遍历的s的位数
        int limit = -Integer.MAX_VALUE;//设置最小值为负的Integer的最大值
        int multmin;
        int digit;

        if (len &gt; 0) {//如果字符串长度大于0，则进行转换
            char firstChar = s.charAt(0);//获取第一位字符
            if (firstChar &lt; '0') { // Possible leading &quot;+&quot; or &quot;-&quot;
                if (firstChar == '-') {//判断是否为负数 
                    negative = true; 
                    limit = Integer.MIN_VALUE;//将限制转换为Integer的最小值，不能小于Integer的最小值  
                } else if (firstChar != '+')
                    throw NumberFormatException.forInputString(s);//第一个char不为+也不为-，则抛出异常  

                if (len == 1) // Cannot have lone &quot;+&quot; or &quot;-&quot;
                    throw NumberFormatException.forInputString(s);//若只有一个符号，则抛出异常
                i++;
            }
            multmin = limit / radix;//设定不同进制下的极限值  
            while (i &lt; len) {//进行进制的转换
                // Accumulating negatively avoids surprises near MAX_VALUE
                digit = Character.digit(s.charAt(i++),radix);//将数字字符串转换成要求的进制数，使用工具类，每次遍历对一个字符进行操作转换  
                if (digit &lt; 0) {
                    throw NumberFormatException.forInputString(s);
                }
                if (result &lt; multmin) {
                    throw NumberFormatException.forInputString(s);
                }
                result *= radix;
                if (result &lt; limit + digit) {
                    throw NumberFormatException.forInputString(s);
                }
                result -= digit;
            }
        } else {
            throw NumberFormatException.forInputString(s);
        }
        return negative ? result : -result;//根据符号返回正数还是负数
    }
    //看吧，我们经常用的parseInt只是个帮我们制定好10进制规则的静态方法
    public static int parseInt(String s) throws NumberFormatException {
        return parseInt(s,10);
    }
    //强大的内部类缓存机制吗，内部字符缓存类
	private static class IntegerCache {
		//缓存的下界，-128，不可变  
        static final int low = -128;
         //缓存上界，暂为null
        static final int high;
        static final Integer cache[];//利用数组来缓存
        //原理：初始化数组将一定范围的整数放到cache数组中，然后在调valueOf方法的时候首先判断范围然后从缓存数组中去抓取数据

        static {
            // high value may be configured by property
            // 缓存上届，可以通过JVM属性来配置
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
            //获取,得到上界
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;
			//获取Integer中所有能保存的数据，初始化缓存数组
            cache = new Integer[(high - low) + 1];
            int j = low;
            //缓存所有Integer的数据
            for(int k = 0; k &lt; cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high &gt;= 127;
        }

        private IntegerCache() {}
    }
    //还有这个我们经常用的，官方也推荐使用这个方法去创建对象的
       public static Integer valueOf(int i) {
       //如果i在Integer缓存中，则直接取出
        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
       //否则，直接创建一个实例
        return new Integer(i);
    }
}
</code></pre>

<h3 id="使用integer事例代码">使用Integer事例代码：</h3>

<pre><code class="language-java">	//会打印出10这个字符串
    public static void main (String []args) {
        Integer i =null;
        i = Integer.valueOf(10);
        System.out.println(&quot;&gt;&gt;&gt;&gt;&quot;+i.toString());
    }
123456
public static void main(String[] args) {
        Integer a1 = 1;
        Integer a2 = 1;

        Integer b1 = 200;
        Integer b2 = 200;

        Integer c1 = Integer.valueOf(1);
//        Integer c2 = new Integer(1);      官方不推荐这种建对象的方法喔
        Integer c2 = Integer.valueOf(1);

        Integer d1 = Integer.valueOf(200);
        Integer d2 = Integer.valueOf(200);


        System.out.println(&quot;a1==a2?&quot; + (a1 == a2));
        System.out.println(&quot;b1==b2?&quot; + (b1 == b2));
        System.out.println(&quot;c1==c2?&quot; + (c1 == c2));
        System.out.println(&quot;d1==d2?&quot; + (d1 == d2));
    }
</code></pre>

<h4 id="上面一段代码的运行结果就是我们要深思的东西啦-也是结合源码要懂的东西">上面一段代码的运行结果就是我们要深思的东西啦，也是结合源码要懂的东西。</h4>

<pre><code class="language-java">a1==a2? true 
b1==b2? false 
c1==c2? false 
d1==d2? false
</code></pre>

<p>第一个为什么是true呢，因为Integer的缓存机制嘛，刚刚我们看到的，缓存了[-128,127]，这些可以直接取出。而剩余的为什么是false，因为他们都超过了缓存的那个范围，就建了个新对象咯。</p>

<p>至于short、float、double这类的包装类设计原理有的跟Integer差不多，但是比如Double，很难去阅读，感觉自己程度还不够，以后会补上。而Character这个包装类，，源码8000多行，我们就讨论它的一些基本知识吧。</p>

<h3 id="4-character的基本了解">4.Character的基本了解：</h3>

<p>Character 类在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，从小写转换成大写。Character 类的方法和数据是通过 UnicodeData 文件中的信息定义的。至于Unicode 大家就百度了解下就好。</p>

<h3 id="5-还有一份挺重要的源码-就是long类">5.还有一份挺重要的源码，就是Long类：</h3>

<pre><code class="language-java">public final class Long extends Number implements Comparable&lt;Long&gt; {
	@Native public static final long MIN_VALUE = 0x8000000000000000L;//最小值为2的63次方-1 
	@Native public static final long MAX_VALUE = 0x7fffffffffffffffL;//最大值为-2的63次方 
	public static final Class&lt;Long&gt;     TYPE = (Class&lt;Long&gt;) Class.getPrimitiveClass(&quot;long&quot;);
	//toString方法与Integer中的toString实现原理一样的。
	
	//转换成对应的进制的字符串表示
	public static String toUnsignedString(long i, int radix) {
        if (i &gt;= 0)
            return toString(i, radix);
        else {
            switch (radix) {
            case 2:
                return toBinaryString(i);//将Long转为2进制  

            case 4:
                return toUnsignedString0(i, 2);//将Long转为4进制  

            case 8:
                return toOctalString(i);//将Long转为8进制  

            case 10:
                /*
                 * We can get the effect of an unsigned division by 10
                 * on a long value by first shifting right, yielding a
                 * positive value, and then dividing by 5.  This
                 * allows the last digit and preceding digits to be
                 * isolated more quickly than by an initial conversion
                 * to BigInteger.
                 */
                long quot = (i &gt;&gt;&gt; 1) / 5;、//十进制嘛
                long rem = i - quot * 10;
                return toString(quot) + rem;

            case 16:
                return toHexString(i);

            case 32:
                return toUnsignedString0(i, 5);

            default:
                return toUnsignedBigInteger(i).toString(radix);
            }
        }
    }
    //返回一个BigInteger等于参数的无符号值
     private static BigInteger toUnsignedBigInteger(long i) {
        if (i &gt;= 0L)
            return BigInteger.valueOf(i);
        else {
            int upper = (int) (i &gt;&gt;&gt; 32);
            int lower = (int) i;

            // return (upper &lt;&lt; 32) + lower
            return (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32).
                add(BigInteger.valueOf(Integer.toUnsignedLong(lower)));
        }
    }
    public static String toHexString(long i) {//将Long转为16进制  
        return toUnsignedString(i, 4);  
    }  
    public static String toOctalString(long i) {//将Long转为8进制  
        return toUnsignedString(i, 3);  
    }  
    public static String toBinaryString(long i) {//将Long转为2进制  
        return toUnsignedString(i, 1);  
    static int stringSize(long x) {//展示Long的字符串长度  
        long p = 10;  
        for (int i=1; i&lt;19; i++) {//每次乘十进行比较  
            if (x &lt; p)  
                return i;  
            p = 10*p;  
        }  
        return 19;  
    }  
    //这个也跟Integer的实现差不多。将字符串参数解析为有符号的整数。
    public static long parseLong(String s, int radix)
              throws NumberFormatException
    {
        if (s == null) {//参数检验
            throw new NumberFormatException(&quot;null&quot;);
        }

        if (radix &lt; Character.MIN_RADIX) {
            throw new NumberFormatException(&quot;radix &quot; + radix +
                                            &quot; less than Character.MIN_RADIX&quot;);
        }
        if (radix &gt; Character.MAX_RADIX) {
            throw new NumberFormatException(&quot;radix &quot; + radix +
                                            &quot; greater than Character.MAX_RADIX&quot;);
        }

        long result = 0;
        boolean negative = false;//这，，跟Integer基本一样的呀
        int i = 0, len = s.length();
        long limit = -Long.MAX_VALUE;
        long multmin;
        int digit;

        if (len &gt; 0) {
            char firstChar = s.charAt(0);
            if (firstChar &lt; '0') { // Possible leading &quot;+&quot; or &quot;-&quot;
                if (firstChar == '-') {
                    negative = true;
                    limit = Long.MIN_VALUE;
                } else if (firstChar != '+')
                    throw NumberFormatException.forInputString(s);

                if (len == 1) // Cannot have lone &quot;+&quot; or &quot;-&quot;
                    throw NumberFormatException.forInputString(s);
                i++;
            }
            multmin = limit / radix;
            while (i &lt; len) {
                // Accumulating negatively avoids surprises near MAX_VALUE
                digit = Character.digit(s.charAt(i++),radix);
                if (digit &lt; 0) {
                    throw NumberFormatException.forInputString(s);
                }
                if (result &lt; multmin) {
                    throw NumberFormatException.forInputString(s);//转化为了负数进行计算，所以要用&lt;号  
                }
                result *= radix;
                if (result &lt; limit + digit) {
                    throw NumberFormatException.forInputString(s);
                }
                result -= digit;
            }
        } else {
            throw NumberFormatException.forInputString(s);
        }
        return negative ? result : -result;
    }
    public static long parseLong(String s) throws NumberFormatException {//默认转成10进制  
        return parseLong(s, 10);  
    }  
    //官方推荐的创建Long对象的方法啦
    public static Long valueOf(String s, int radix) throws NumberFormatException {  
        return Long.valueOf(parseLong(s, radix));  
    }  
    public static Long valueOf(String s) throws NumberFormatException  
    {  
        return Long.valueOf(parseLong(s, 10));  
    }
    //Long的默认缓存，-128~127，缓存模块与Integer相同  
     private static class LongCache {
        private LongCache(){}

        static final Long cache[] = new Long[-(-128) + 127 + 1];

        static {
            for(int i = 0; i &lt; cache.length; i++)
                cache[i] = new Long(i - 128);
        }
    }
    public static Long valueOf(long l) {
        final int offset = 128;
        //在缓存范围内则直接使用咯
        if (l &gt;= -128 &amp;&amp; l &lt;= 127) { // will cache
            return LongCache.cache[(int)l + offset];
        }
        return new Long(l);
    }
    public int hashCode() {//重写hashcode()方法，无符号右移32位后乘value本身  
        return (int)(value ^ (value &gt;&gt;&gt; 32));  
    }  
    public boolean equals(Object obj) {  
        if (obj instanceof Long) {  
            return value == ((Long)obj).longValue();//比较的是value的地址值，所以在缓存范围内的相等，缓存范围外的不等（两个对象指向同一个Long除外）  
        }  
        return false;  
    }    
}
</code></pre>

<h3 id="6-列出一下包装类的-共性">6.列出一下包装类的<strong>共性</strong>：</h3>

<p>（1）带有基本值参数并创建包装类对象的构造函数.如可以利用Integer包装类创建对象,Integer obj=new Integer(145)
Integer obj=new Integer(145);</p>

<p>（2）带有字符串参数并创建包装类对象的构造函数.如new Integer(&ldquo;-45.36&rdquo;);</p>

<p>（3）可生成对象基本值的typeValue方法,如obj.intValue();
int num=obj.intValue();</p>

<p>（4）将字符串转换为基本值的 parseType方法,如Integer.parseInt(args[0]);</p>

<p>（5）因为有装进Map的几率，所以java设计了包装类里的哈希值，生成哈稀表代码的hashCode方法,如obj.hasCode();</p>

<p>（6）对同一个类的两个对象进行比较的equals()方法,如obj1.eauqls(obj2);</p>

<p>（7）生成字符串表示法的toString()方法,如obj.toString().</p>

<p>（8）自动装包/拆包大大方便了基本类型数据和它们包装类地使用。
自动装包：基本类型自动转为包装类。例如(int &gt;&gt; Integer)
自动拆包：包装类自动转为基本类型。例如(Integer &gt;&gt; int)</p>

<hr />

<h2 id="三-数据类型转换-装包拆包等一些小坑">三、数据类型转换、装包拆包等一些小坑。</h2>

<h4 id="1-类型转换">（1）.类型转换：</h4>

<p>基础：
1.自动类型转换-系统支持把某种基本类型的值直接赋给另一种基本类型的变量。
规则：如下图，从左到右自动转换。
<img src="https://img-blog.csdnimg.cn/20181209173041733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX0Zyb3N0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>

<p>2.强制类型转换-视图把表数范围大的类型转换为表数范围小的类型时，容器引起信息丢失。另：字符串不能直接转换为基本类型，但可通过基本类型对应的包装类实现转换成基本类型。如以下代码：</p>

<pre><code class="language-java">String a = &quot;45&quot;;
int value=Integer.parseInt(a);
</code></pre>

<p>3.自动提升规则：当一个算术表达式中包含多个基本类型的值时，所有的byte类、short和char类型会被提示到int类型</p>

<h4 id="2-自动装包与拆包-自动装包-拆包大大方便了基本类型数据和它们包装类地使用">（2）自动装包与拆包：自动装包/拆包大大方便了基本类型数据和它们包装类地使用。</h4>

<p>自动装包：基本类型自动转为包装类.(int　&gt;&gt;　Integer)</p>

<p>自动拆包：包装类自动转为基本类型.(Integer　&gt;&gt;　int)</p>

<p>使用装包后，我们就可以用集合去存放基本类型啦。比如：Integer先自动转换为int进行加法运算，然后int再次转换为Integer。</p>

<pre><code class="language-java">int　a　=　3;
Collection　c　=　new　ArrayList();
c.add(a);//自动转换成Integer.自动装包
Integer　b　=　new　Integer(2);
c.add(b　+　2);
</code></pre>

<hr />

<h3 id="好了-深入java基础-一-基本数据类型及其包装类讲完了">好了，深入Java基础（一）——基本数据类型及其包装类讲完了。</h3>

<p>本博客是经过仔细其他类型的博客，结合源代码注释，并在这里做出进一步拓展以及写出自己的理解。另外，这个系列会逐步更新，也希望阅读更多源码，分享经验给大家。欢迎在下面指出错误，共同学习！！你的点赞是对我最好的支持！！
这个系列的文章因为涉及很多源码，所以会根据网友们的反应以及我的学习深入去补充。希望大家一起来讨论学习。</p>
                        </div>

                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/java%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98/">Java中的数据类型与内存</a></li>
        
        <li><a href="/posts/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Java基本数据类型</a></li>
        
        <li><a href="/posts/tomcat%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/">Tomcat端口被占用</a></li>
        
        <li><a href="/posts/axure/">Axure</a></li>
        
        <li><a href="/posts/git/">Git基本操作</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://vvc-Dream.github.io/tags/java">java</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://vvc-Dream.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/%E6%89%8B%E6%9C%BApc%E6%8A%95%E5%B1%8F/" title="手机PC投屏">手机PC投屏</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/win10%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/" title="Win10效率工具">Win10效率工具</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/win10%E7%BE%8E%E5%8C%96/" title="Win10美化">Win10美化</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/java%E9%9D%A2%E8%AF%953/" title="Java面试（3）">Java面试（3）</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/java%E9%9D%A2%E8%AF%95%E8%BF%9B%E9%98%B6/" title="Java面试（进阶）">Java面试（进阶）</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/mysql%E7%B4%A2%E5%BC%95/" title="Mysql索引">Mysql索引</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/java%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/" title="Java单点登陆">Java单点登陆</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/seeion%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E5%88%9B%E5%BB%BA%E7%9A%84/" title="Seeion是什么时候被创建的">Seeion是什么时候被创建的</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/object%E7%B1%BB/" title="Object类">Object类</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/posts/java%E9%9D%A2%E8%AF%95/" title="Java面试">Java面试</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://vvc-Dream.github.io/categories/%E5%B7%A5%E5%85%B7/">工具(2)</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/categories/%E5%BC%80%E5%8F%91/">开发(21)</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/categories/%E6%9D%82%E6%8A%80%E6%B5%85%E5%B0%9D/">杂技浅尝(1)</a>
    </li>
    
    <li>
        <a href="https://vvc-Dream.github.io/categories/%E7%BE%8E%E5%8C%96/">美化(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://vvc-Dream.github.io/tags/hugo/">hugo</a>
    
    <a href="https://vvc-Dream.github.io/tags/insurance/">insurance</a>
    
    <a href="https://vvc-Dream.github.io/tags/java/">java</a>
    
    <a href="https://vvc-Dream.github.io/tags/win/">win</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://github.com/vvc-Dream/vvc-Dream.github.io" title="Github">Github</a>
        </li>
        
        <li>
            <a target="_blank" href="http://space.bilibili.com/44178647?" title="哔哩哔哩">哔哩哔哩</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://vvc-Dream.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2018 <a href="https://vvc-Dream.github.io/">vvc-Dream的博客 By vvc-Dream</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
